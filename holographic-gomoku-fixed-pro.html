<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Holographic Gesture Gomoku - Fixed Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #video-feed { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 3; transform: scaleX(-1); border: 2px solid #00ffff; opacity: 0.8; border-radius: 8px; box-shadow: 0 0 20px #00ffff; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; font-size: 24px; z-index: 10; text-shadow: 0 0 20px #00ffff; text-align: center; }
        #hud { position: absolute; bottom: 20px; left: 20px; color: #00ffff; z-index: 4; font-size: 14px; background: rgba(0, 20, 40, 0.8); padding: 15px; border: 2px solid #00ffff; border-radius: 10px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
        #controls { position: absolute; bottom: 20px; right: 20px; color: #00ffff; z-index: 4; font-size: 13px; background: rgba(0, 20, 40, 0.8); padding: 15px; border: 2px solid #00ffff; border-radius: 10px; max-width: 250px; }
        .hidden { display: none !important; }
        .status-player { color: #00ffff !important; text-shadow: 0 0 10px #00ffff; }
        .status-ai { color: #ff0033 !important; text-shadow: 0 0 10px #ff0033; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        ğŸš€ Initializing Neural Interface...<br>
        <small style="font-size:14px; color: #aaa; margin-top: 10px; display: block;">Please allow camera access</small>
    </div>
    
    <video id="video-feed" autoplay playsinline muted></video>
    <canvas id="overlay-canvas"></canvas>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <div style="font-weight: bold; margin-bottom: 8px; font-size: 16px;">ğŸ® GAME STATUS</div>
        Status: <span id="status-text" class="status-player">System Booting...</span><br>
        Gesture: <span id="gesture-text">Waiting...</span><br>
        <div style="margin-top: 8px; font-size: 11px; opacity: 0.7;">
            Player: <span style="color: #00ffff;">â—</span> Cyan (Sphere) | 
            AI: <span style="color: #ff0033;">â– </span> Red (Cube)
        </div>
    </div>
    
    <div id="controls">
        <div style="font-weight: bold; margin-bottom: 8px;">âœ‹ GESTURE CONTROLS</div>
        <div style="font-size: 12px; line-height: 1.6;">
            ğŸ‘† Index finger controls cursor<br>
            ğŸ¤ Pinch thumb + index to place<br>
            ğŸ§² Distance &lt; 10% = Magnetic Lock<br>
            â±ï¸ Hold pinch 100ms to confirm
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let handLandmarker, video;
        let boardGrid = [];
        let pieces = [];
        let cursorMesh, lockIndicator;
        let shockwaves = [];
        let lasers = [];
        let particles = [];
        
        // æ¸¸æˆçŠ¶æ€
        const BOARD_SIZE = 15;
        const CELL_SIZE = 2; // 3Dä¸–ç•Œå•ä½
        let gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0)); // 0:ç©º, 1:ç©å®¶, 2:AI
        let isPlayerTurn = true;
        let lastPinchState = false;
        let pinchStartTime = 0;
        
        // é¢œè‰²å¸¸é‡
        const CYAN = 0x00ffff;
        const RED = 0xee0022;  // æ›´çº¯æ­£çš„çº¢è‰²ï¼Œé¿å…è¿‡åº¦æ›å…‰

        // åˆå§‹åŒ–
        async function init() {
            console.log('ğŸš€ ===== INITIALIZATION START =====');
            setupScene();
            setupPostProcessing();
            createBoard();
            createCursor();
            await setupMediaPipe();
            
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('status-text').innerText = "Active - Your Turn!";
            
            console.log('âœ… Initialization complete!');
            animate();
        }

        // --- Three.js åœºæ™¯è®¾ç½® ---
        function setupScene() {
            console.log('ğŸ“¦ Setting up 3D scene...');
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            
            // æ·±ç©ºèƒŒæ™¯ - å‡å°‘é›¾æ•ˆä»¥æé«˜æ¸…æ™°åº¦
            scene.fog = new THREE.FogExp2(0x000510, 0.01);  // ä»0.015é™ä½åˆ°0.01
            scene.background = new THREE.Color(0x000510);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // æ›´å¼ºçš„ç…§æ˜
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
            dirLight1.position.set(10, 25, 10);
            scene.add(dirLight1);
            
            const dirLight2 = new THREE.DirectionalLight(0x0088ff, 1);
            dirLight2.position.set(-10, 20, -10);
            scene.add(dirLight2);

            // æ›´ç¾è§‚çš„ç½‘æ ¼è®¾è®¡
            const gridSize = BOARD_SIZE * CELL_SIZE;
            const divisions = BOARD_SIZE;
            
            // ä¸»ç½‘æ ¼çº¿ï¼ˆæ›´äº®ã€æ›´ç²—ï¼‰
            const gridHelper = new THREE.GridHelper(gridSize, divisions, CYAN, 0x003344);
            gridHelper.material.opacity = 0.8;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // æ·»åŠ æ¬¡çº§ç½‘æ ¼çº¿ï¼ˆç»†å¯†çš„è¾…åŠ©çº¿ï¼‰
            const subGridHelper = new THREE.GridHelper(gridSize, divisions * 3, 0x002233, 0x001122);
            subGridHelper.material.opacity = 0.3;
            subGridHelper.material.transparent = true;
            subGridHelper.position.y = -0.01;
            scene.add(subGridHelper);
            
            // æ£‹ç›˜å¤–æ¡†åŠ å¼º
            const borderMaterial = new THREE.LineBasicMaterial({ 
                color: CYAN, 
                linewidth: 2,
                transparent: true,
                opacity: 1
            });
            const borderSize = gridSize / 2;
            const borderPoints = [
                new THREE.Vector3(-borderSize, 0, -borderSize),
                new THREE.Vector3(borderSize, 0, -borderSize),
                new THREE.Vector3(borderSize, 0, borderSize),
                new THREE.Vector3(-borderSize, 0, borderSize),
                new THREE.Vector3(-borderSize, 0, -borderSize)
            ];
            const borderGeometry = new THREE.BufferGeometry().setFromPoints(borderPoints);
            const borderLine = new THREE.Line(borderGeometry, borderMaterial);
            borderLine.position.y = 0.02;
            scene.add(borderLine);
            
            // æ·»åŠ å†…æ¡†è£…é¥°
            const innerBorderSize = borderSize * 0.95;
            const innerBorderPoints = [
                new THREE.Vector3(-innerBorderSize, 0, -innerBorderSize),
                new THREE.Vector3(innerBorderSize, 0, -innerBorderSize),
                new THREE.Vector3(innerBorderSize, 0, innerBorderSize),
                new THREE.Vector3(-innerBorderSize, 0, innerBorderSize),
                new THREE.Vector3(-innerBorderSize, 0, -innerBorderSize)
            ];
            const innerBorderGeometry = new THREE.BufferGeometry().setFromPoints(innerBorderPoints);
            const innerBorderMaterial = new THREE.LineBasicMaterial({ 
                color: CYAN, 
                linewidth: 1,
                transparent: true,
                opacity: 0.5
            });
            const innerBorderLine = new THREE.Line(innerBorderGeometry, innerBorderMaterial);
            innerBorderLine.position.y = 0.01;
            scene.add(innerBorderLine);

            window.addEventListener('resize', onWindowResize);
            console.log('âœ… Scene setup complete');
        }

        // --- è¾‰å…‰ç‰¹æ•ˆ ---
        function setupPostProcessing() {
            console.log('âœ¨ Setting up bloom effects...');
            const renderScene = new RenderPass(scene, camera);
            
            // è°ƒæ•´Bloomå‚æ•°ï¼šé™ä½å¼ºåº¦é¿å…è¿‡åº¦æ›å…‰
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                0.8,  // å¼ºåº¦ä»2.0é™ä½åˆ°0.8
                0.4,  // åŠå¾„ä»0.6é™ä½åˆ°0.4
                0.5   // é˜ˆå€¼ä»0.3æé«˜åˆ°0.5ï¼ˆå‡å°‘å‘å…‰ç‰©ä½“ï¼‰
            );

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            console.log('âœ… Bloom effects ready');
        }

        function createBoard() {
            // ç¾è§‚çš„çº¯çº¿æ¡æ£‹ç›˜è®¾è®¡ï¼Œæ— ç‚¹æ ‡è®°
            console.log('ğŸ¨ Creating elegant board design...');
        }

        function createCursor() {
            console.log('ğŸ¯ Creating cursor...');
            // å¤–åœˆ
            const geometry = new THREE.RingGeometry(0.9, 1.1, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: CYAN, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.9 
            });
            cursorMesh = new THREE.Mesh(geometry, material);
            cursorMesh.rotation.x = -Math.PI / 2;
            cursorMesh.visible = false;
            scene.add(cursorMesh);
            
            // å†…åœˆ
            const innerGeo = new THREE.RingGeometry(0.6, 0.8, 32);
            const innerMat = new THREE.MeshBasicMaterial({ 
                color: CYAN, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.5 
            });
            const innerRing = new THREE.Mesh(innerGeo, innerMat);
            innerRing.rotation.x = -Math.PI / 2;
            innerRing.position.y = 0.05;
            cursorMesh.add(innerRing);

            // é”å®šæŒ‡ç¤ºå™¨
            const lockGeo = new THREE.CircleGeometry(0.4, 16);
            const lockMat = new THREE.MeshBasicMaterial({ color: RED });
            lockIndicator = new THREE.Mesh(lockGeo, lockMat);
            lockIndicator.rotation.x = -Math.PI / 2;
            lockIndicator.position.y = 0.1;
            cursorMesh.add(lockIndicator);
            lockIndicator.visible = false;
            
            console.log('âœ… Cursor created');
        }

        // --- MediaPipe è®¾ç½® ---
        async function setupMediaPipe() {
            console.log('ğŸ“¹ Setting up MediaPipe...');
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                video = document.getElementById('video-feed');
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } 
                    });
                    video.srcObject = stream;
                    await new Promise((resolve) => { video.onloadedmetadata = () => resolve(); });
                    video.play();
                    console.log('âœ… Camera initialized');
                } else {
                    alert("Camera not available!");
                }
            } catch (error) {
                console.error('âŒ MediaPipe setup failed:', error);
                alert('Camera initialization failed. Please check permissions.');
            }
        }

        // --- æ¸¸æˆé€»è¾‘ï¼šè½å­ ---
        function placePiece(gx, gz, isPlayer) {
            console.log(`\nğŸ® ===== PLACING PIECE =====`);
            console.log(`   Player: ${isPlayer ? 'Human (Cyan)' : 'AI (Red)'}`);
            console.log(`   Grid position: [${gx}, ${gz}]`);
            console.log(`   Board status: ${gameBoard[gx][gz]}`);
            
            if (gameBoard[gx][gz] !== 0) {
                console.log('âŒ Position occupied!');
                return;
            }

            gameBoard[gx][gz] = isPlayer ? 1 : 2;
            console.log('âœ… Board updated');

            // è®¡ç®—ä¸–ç•Œåæ ‡
            const offset = (BOARD_SIZE * CELL_SIZE) / 2 - (CELL_SIZE / 2);
            const wx = gx * CELL_SIZE - offset;
            const wz = gz * CELL_SIZE - offset;
            console.log(`   World position: (${wx.toFixed(2)}, ${wz.toFixed(2)})`);

            // åˆ›å»ºæ£‹å­
            let geometry, color, pieceName;
            
            if (isPlayer) {
                // ç©å®¶ï¼šé’è‰²çƒä½“
                geometry = new THREE.SphereGeometry(0.9, 32, 32);
                color = CYAN;
                pieceName = 'CYAN_SPHERE';
            } else {
                // AIï¼šçº¢è‰²ç«‹æ–¹ä½“ï¼ˆé™ä½å‘å…‰é¿å…è¿‡åº¦æ›å…‰ï¼‰
                geometry = new THREE.BoxGeometry(1.6, 1.6, 1.6);
                color = RED;
                pieceName = 'RED_CUBE';
            }
            
            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: color, 
                emissiveIntensity: isPlayer ? 1.2 : 1.8,  // AIä»3.5é™ä½åˆ°1.8
                roughness: 0.2,
                metalness: 0.8
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(wx, isPlayer ? 0.9 : 1.2, wz);
            mesh.name = pieceName;
            
            // é™ä½ç‚¹å…‰æºå¼ºåº¦
            const lightIntensity = isPlayer ? 6 : 10;  // AIä»20é™ä½åˆ°10
            const lightDistance = isPlayer ? 8 : 12;   // AIä»15é™ä½åˆ°12
            const pointLight = new THREE.PointLight(color, lightIntensity, lightDistance);
            pointLight.position.set(0, 0, 0);
            mesh.add(pointLight);
            
            // é™ä½å¤–å‘å…‰å¼ºåº¦
            const glowSize = isPlayer ? 1.1 : 1.8;     // AIä»2.0é™ä½åˆ°1.8
            const glowGeo = isPlayer ? 
                new THREE.SphereGeometry(glowSize, 16, 16) : 
                new THREE.BoxGeometry(glowSize, glowSize, glowSize);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: isPlayer ? 0.25 : 0.35,        // AIä»0.6é™ä½åˆ°0.35
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            mesh.add(glow);
            
            scene.add(mesh);
            pieces.push({ mesh: mesh, glow: glow, isRed: !isPlayer });
            
            console.log(`âœ… ${pieceName} created and added to scene`);
            console.log(`   Total pieces: ${pieces.length}`);
            console.log(`   Scene children: ${scene.children.length}`);

            // ç‰¹æ•ˆ
            if (isPlayer) {
                createShockwave(wx, wz, CYAN);
                createParticleBurst(wx, wz, CYAN);
            } else {
                createOrbitalLaser(wx, wz);
                setTimeout(() => {
                    createShockwave(wx, wz, RED);
                    createParticleBurst(wx, wz, RED);
                }, 600);
            }

            // æ£€æŸ¥èƒœåˆ©ï¼ˆç®€åŒ–ç‰ˆï¼‰
            if (checkWin(gx, gz, isPlayer ? 1 : 2)) {
                console.log(`ğŸ† ${isPlayer ? 'PLAYER' : 'AI'} WINS!`);
                setTimeout(() => {
                    alert(isPlayer ? 'ğŸ‰ You Win!' : 'ğŸ’€ AI Wins!');
                    location.reload();
                }, 1000);
                return;
            }

            // è½®æ¢å›åˆ
            isPlayerTurn = !isPlayerTurn;
            updateStatus();

            if (!isPlayerTurn) {
                setTimeout(aiMove, 1200);
            }
            
            console.log('ğŸ® ===== PIECE PLACEMENT COMPLETE =====\n');
        }

        function updateStatus() {
            const statusEl = document.getElementById('status-text');
            if (isPlayerTurn) {
                statusEl.innerText = "Your Turn - Place Cyan Piece";
                statusEl.className = 'status-player';
            } else {
                statusEl.innerText = "AI Thinking...";
                statusEl.className = 'status-ai';
            }
        }

        // --- AI é€»è¾‘ ---
        function aiMove() {
            console.log('\nğŸ¤– ===== AI TURN =====');
            let bestScore = -Infinity;
            let move = null;
            
            for(let x = 0; x < BOARD_SIZE; x++) {
                for(let z = 0; z < BOARD_SIZE; z++) {
                    if(gameBoard[x][z] === 0) {
                        let score = -Math.abs(x - 7) - Math.abs(z - 7); 
                        score += Math.random() * 3;
                        
                        // ç®€å•é˜²å®ˆï¼šæ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰ç©å®¶æ£‹å­
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const nx = x + dx;
                                const nz = z + dz;
                                if (nx >= 0 && nx < BOARD_SIZE && nz >= 0 && nz < BOARD_SIZE) {
                                    if (gameBoard[nx][nz] === 1) score += 5;
                                }
                            }
                        }
                        
                        if(score > bestScore) {
                            bestScore = score;
                            move = {x, z};
                        }
                    }
                }
            }

            if(move) {
                console.log(`âœ… AI chose position [${move.x}, ${move.z}]`);
                placePiece(move.x, move.z, false);
            }
        }

        // --- èƒœåˆ©æ£€æŸ¥ ---
        function checkWin(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            
            for (let [dx, dy] of directions) {
                let count = 1;
                
                for (let i = 1; i < 5; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                        gameBoard[nx][ny] === player) {
                        count++;
                    } else break;
                }
                
                for (let i = 1; i < 5; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                        gameBoard[nx][ny] === player) {
                        count++;
                    } else break;
                }
                
                if (count >= 5) return true;
            }
            return false;
        }

        // --- ç‰¹æ•ˆç³»ç»Ÿ ---
        function createShockwave(x, z, colorHex) {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const geometry = new THREE.RingGeometry(0.5, 0.7, 32);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: colorHex, 
                        transparent: true, 
                        side: THREE.DoubleSide,
                        opacity: 0.6  // ä»0.8é™ä½åˆ°0.6
                    });
                    const wave = new THREE.Mesh(geometry, material);
                    wave.position.set(x, 0.1 + i * 0.05, z);
                    wave.rotation.x = -Math.PI / 2;
                    scene.add(wave);
                    shockwaves.push({ mesh: wave, scale: 1, opacity: 0.6, speed: 0.08 + i * 0.03 });
                }, i * 100);
            }
        }

        function createParticleBurst(x, z, colorHex) {
            for (let i = 0; i < 12; i++) {  // ä»15å‡å°‘åˆ°12
                const pGeo = new THREE.SphereGeometry(0.06, 8, 8);  // ä»0.08å‡å°åˆ°0.06
                const pMat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.8 });
                const particle = new THREE.Mesh(pGeo, pMat);
                particle.position.set(x, 1, z);
                
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 0.06 + Math.random() * 0.06;
                
                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.random() * 0.12,
                        z: Math.sin(angle) * speed
                    },
                    life: 1
                });
            }
        }

        function createOrbitalLaser(x, z) {
            console.log(`âš¡ Creating laser at (${x.toFixed(2)}, ${z.toFixed(2)})`);
            
            const geometry = new THREE.CylinderGeometry(0.25, 0.25, 50, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: RED, 
                transparent: true, 
                opacity: 0.8  // é™ä½é€æ˜åº¦
            });
            const laser = new THREE.Mesh(geometry, material);
            laser.position.set(x, 25, z);
            
            // é™ä½å¤–å‘å…‰å¼ºåº¦
            const glowGeo = new THREE.CylinderGeometry(0.35, 0.35, 50, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: RED,
                transparent: true,
                opacity: 0.4,  // ä»0.6é™ä½åˆ°0.4
                side: THREE.BackSide
            });
            const glowLaser = new THREE.Mesh(glowGeo, glowMat);
            laser.add(glowLaser);
            
            // é™ä½å…‰æºå¼ºåº¦
            const light = new THREE.PointLight(RED, 15, 30);  // ä»30é™ä½åˆ°15ï¼ŒèŒƒå›´ä»40é™åˆ°30
            light.position.set(x, 25, z);
            scene.add(light);
            
            scene.add(laser);
            lasers.push({ mesh: laser, light: light, life: 1.0, speed: 0.03 });
            
            console.log('âœ… Laser created');
        }

        // --- ä¸»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // 1. MediaPipe æ£€æµ‹
            if (video && video.readyState >= 2 && handLandmarker) {
                let startTimeMs = performance.now();
                const results = handLandmarker.detectForVideo(video, startTimeMs);
                
                draw2DSkeleton(results);

                if (results.landmarks.length > 0 && isPlayerTurn) {
                    const landmarks = results.landmarks[0];
                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];

                    // æ˜ å°„æ‰‹åŠ¿åæ ‡ï¼ˆé•œåƒä¿®æ­£ï¼‰
                    const boardWidthWorld = BOARD_SIZE * CELL_SIZE;
                    
                    // ä¿®æ­£ï¼šä½¿ç”¨ (1 - x) å®ç°å®Œå…¨é•œåƒ
                    const mapX = ((1 - indexTip.x) - 0.5) * boardWidthWorld * 1.3;
                    const mapZ = (indexTip.y - 0.5) * boardWidthWorld * 1.2;

                    // é™åˆ¶èŒƒå›´
                    const limit = (BOARD_SIZE * CELL_SIZE) / 2;
                    const clampedX = Math.max(-limit, Math.min(limit, mapX));
                    const clampedZ = Math.max(-limit, Math.min(limit, mapZ));

                    // è½¬æ¢ä¸ºç½‘æ ¼ç´¢å¼•
                    const offset = (BOARD_SIZE * CELL_SIZE) / 2 - (CELL_SIZE / 2);
                    const gx = Math.max(0, Math.min(BOARD_SIZE - 1, Math.round((clampedX + offset) / CELL_SIZE)));
                    const gz = Math.max(0, Math.min(BOARD_SIZE - 1, Math.round((clampedZ + offset) / CELL_SIZE)));

                    // å¸é™„åçš„ä¸–ç•Œåæ ‡
                    const snapWx = gx * CELL_SIZE - offset;
                    const snapWz = gz * CELL_SIZE - offset;

                    cursorMesh.visible = true;
                    
                    // æåˆæ£€æµ‹
                    const dx = indexTip.x - thumbTip.x;
                    const dy = indexTip.y - thumbTip.y;
                    const dz = indexTip.z - thumbTip.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    const isPinching = dist < 0.05;
                    const isNearPinch = dist < 0.1;
                    
                    if (isNearPinch) {
                        // ç£å¸é”å®š
                        cursorMesh.position.set(snapWx, 0.15, snapWz);
                        document.getElementById('gesture-text').innerText = isPinching ? 
                            "ğŸ¯ PINCH LOCKED - Placing..." : "ğŸ§² Magnetic Lock Active";
                        lockIndicator.visible = isPinching;

                        if (isPinching && !lastPinchState) {
                            pinchStartTime = Date.now();
                        }
                        
                        if (isPinching && lastPinchState && (Date.now() - pinchStartTime > 100)) {
                            if (gameBoard[gx][gz] === 0) {
                                placePiece(gx, gz, true);
                                lastPinchState = false;
                                pinchStartTime = Date.now() + 1000;
                            }
                        }
                    } else {
                        // è‡ªç”±ç§»åŠ¨
                        cursorMesh.position.set(clampedX, 0.5, clampedZ);
                        lockIndicator.visible = false;
                        document.getElementById('gesture-text').innerText = "ğŸ‘† Moving cursor...";
                    }
                    
                    lastPinchState = isPinching;
                }
            }

            // 2. å…‰æ ‡åŠ¨ç”»
            if (cursorMesh.visible) {
                const pulse = Math.sin(time * 3) * 0.15 + 1;
                cursorMesh.scale.set(pulse, pulse, pulse);
                cursorMesh.rotation.z += 0.02;
            }

            // 3. æ£‹å­å‘å…‰åŠ¨ç”»
            pieces.forEach(piece => {
                if (piece.glow) {
                    const basePulse = piece.isRed ? 0.4 : 0.25;  // é™ä½åŸºç¡€è„‰å†²
                    const pulseAmount = piece.isRed ? 0.2 : 0.15;  // é™ä½è„‰å†²å¹…åº¦
                    const glowPulse = Math.sin(time * 2) * pulseAmount + basePulse;
                    piece.glow.material.opacity = glowPulse;
                    
                    if (piece.isRed) {
                        piece.mesh.rotation.y += 0.01;
                    }
                }
            });

            // 4. éœ‡æ³¢
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                const sw = shockwaves[i];
                sw.scale += sw.speed;
                sw.opacity -= 0.025;
                sw.mesh.scale.set(sw.scale, sw.scale, sw.scale);
                sw.mesh.material.opacity = sw.opacity;
                if (sw.opacity <= 0) {
                    scene.remove(sw.mesh);
                    shockwaves.splice(i, 1);
                }
            }

            // 5. æ¿€å…‰
            for (let i = lasers.length - 1; i >= 0; i--) {
                const l = lasers[i];
                l.mesh.position.y -= l.speed * 60;
                l.light.position.y = l.mesh.position.y;
                l.speed += 0.001;
                l.life -= 0.015;
                l.mesh.material.opacity = l.life * 0.8;
                
                const pulse = Math.sin(time * 20) * 0.15 + 1;
                l.light.intensity = 12 * pulse * l.life;  // ä»30é™ä½åˆ°12
                
                if (l.life <= 0 || l.mesh.position.y < 0) {
                    scene.remove(l.mesh);
                    scene.remove(l.light);
                    lasers.splice(i, 1);
                }
            }

            // 6. ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.x += p.velocity.x;
                p.mesh.position.y += p.velocity.y;
                p.mesh.position.z += p.velocity.z;
                p.velocity.y -= 0.005;
                p.life -= 0.025;  // åŠ å¿«è¡°å‡é€Ÿåº¦
                p.mesh.material.opacity = p.life * 0.8;  // é™ä½æœ€å¤§é€æ˜åº¦
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            composer.render();
        }

        // --- 2Déª¨éª¼ç»˜åˆ¶ ---
        const canvas2d = document.getElementById('overlay-canvas');
        const ctx = canvas2d.getContext('2d');
        
        function draw2DSkeleton(results) {
            canvas2d.width = window.innerWidth;
            canvas2d.height = window.innerHeight;
            ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
            
            if (!results.landmarks || results.landmarks.length === 0) return;

            const landmarks = results.landmarks[0];
            
            // è¿æ¥çº¿
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            
            const connections = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [5,9],[9,10],[10,11],[11,12],
                [9,13],[13,14],[14,15],[15,16],
                [13,17],[17,18],[18,19],[19,20],
                [0,17]
            ];
            
            connections.forEach(([start, end]) => {
                const s = landmarks[start];
                const e = landmarks[end];
                ctx.beginPath();
                ctx.moveTo((1 - s.x) * canvas2d.width, s.y * canvas2d.height);
                ctx.lineTo((1 - e.x) * canvas2d.width, e.y * canvas2d.height);
                ctx.stroke();
            });
            
            // å…³é”®ç‚¹
            ctx.fillStyle = '#00ffff';
            landmarks.forEach(point => {
                ctx.beginPath();
                ctx.arc((1 - point.x) * canvas2d.width, point.y * canvas2d.height, 3, 0, 2*Math.PI);
                ctx.fill();
            });

            // å¼ºè°ƒé£ŸæŒ‡å’Œæ‹‡æŒ‡
            const index = landmarks[8];
            const thumb = landmarks[4];
            
            ctx.fillStyle = '#ff0033';
            ctx.shadowColor = '#ff0033';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc((1 - index.x) * canvas2d.width, index.y * canvas2d.height, 6, 0, 2*Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc((1 - thumb.x) * canvas2d.width, thumb.y * canvas2d.height, 6, 0, 2*Math.PI);
            ctx.fill();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
